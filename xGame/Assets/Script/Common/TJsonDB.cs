// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Reflection;
using MiniJSON;

namespace Common
{
	public class TBaseItemList<T> 
		where T : new()
	{
		public List<T> Datas = new List<T> ();
	}
	
	public class TBaseItemJsonDB<T> : IDisposable
		where T : new()
	{
		public void Dispose()
		{
			m_dicFilters.Clear ();
			m_listDatas.Datas.Clear ();
			m_dicFinder.Clear ();
		}
		
		#region Public Functions
		
		protected TBaseItemJsonDB()
		{
			
		}
		
		public TBaseItemJsonDB(string key, string dataContent)
		{
			m_listDatas = Json.Deserialize (dataContent) as TBaseItemList<T> ;
			if (null == m_listDatas) 
			{
				m_listDatas = new TBaseItemList<T>();
				return;
			}
			m_strMainKey = key;
			Type t = typeof(T);
			FieldInfo[] fields = t.GetFields();
			foreach (FieldInfo field in fields) 
			{
				FieldInfo info = t.GetField (field.Name, BindingFlags.Public | BindingFlags.Instance);
				
				if(field.Name == key)
				{
					for (int iIndex = 0; iIndex < m_listDatas.Datas.Count; iIndex++) 
					{
						object value = info.GetValue(m_listDatas.Datas[iIndex]);
						string strValue = value.ToString();
						if(!m_dicFinder.ContainsKey(strValue))
						{
							m_dicFinder.Add(strValue, iIndex);
						}	
					}
					
					break;
				}
				
			}
		}
		
		public T GetByKey(string key)
		{
			return this [key];
		}
		
		public T this[string key]
		{
			get
			{
				if(m_dicFinder.ContainsKey(key))
				{
					return m_listDatas.Datas[m_dicFinder[key]];
				}

				return default(T);
			}
		}
		
		public bool ContainKey(string key)
		{
			return m_dicFinder.ContainsKey (key);
		}

		public List<T> Filter(string keyName, object value)
		{
			List<T> list = new List<T> ();
			
			Type t = typeof(T);
			FieldInfo[] fields = t.GetFields();
			foreach (FieldInfo field in fields) 
			{
				FieldInfo info = t.GetField (field.Name, BindingFlags.Public | BindingFlags.Instance);
				
				if(field.Name == keyName)
				{
					for(int iIndex = 0; iIndex < m_listDatas.Datas.Count; iIndex++)
					{
						object dataValue = info.GetValue(m_listDatas.Datas[iIndex]);
						if(dataValue.Equals(value))
						{
							list.Add(m_listDatas.Datas[iIndex]);
						}
					}
					
					break;
				}
			}
			
			return list;
		}
		
		public List<T> Filter(Func<T, bool> compareFoo)
		{
			List<T> list = new List<T> ();
			if(null == compareFoo)
			{
				return list;
			}
			
			for (int iIndex = 0; iIndex < m_listDatas.Datas.Count; iIndex++) 
			{
				if(compareFoo.Invoke(m_listDatas.Datas[iIndex]))
				{
					list.Add(m_listDatas.Datas[iIndex]);
				}
			}

			return list;
		}
		
		#endregion 
		
		
		#region Members
		
		// mian key name of class T's filed name
		protected string m_strMainKey = string.Empty;
		// default filter by main key, main key value as dic key, T object index as value
		protected Dictionary<string, int> m_dicFinder = new Dictionary<string, int>();
		// data list
		protected TBaseItemList<T> m_listDatas = new TBaseItemList<T>();
		// fi;ter finder
		protected Dictionary<string, Dictionary<string, int> > m_dicFilters = new Dictionary<string, Dictionary<string, int>>();
		
		#endregion
	}
}

